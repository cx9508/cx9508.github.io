<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++面向对象</title>
    <link href="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h1><h3 id="一、C和C-关于数据和函数"><a href="#一、C和C-关于数据和函数" class="headerlink" title="一、C和C++关于数据和函数"></a>一、C和C++关于数据和函数</h3><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106200318374.png" alt="image-20240106200318374"><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106200522448.png" alt="image-20240106200318374"><p>不同类型的数据创建相应的变量，函数就是处理这些变量。</p><p>C中的数据是共享的，其他的函数也可以处理这些数据。</p><p>C++将数据和函数包起来，放在类或结构体里面，以此为整体创建对象。</p><h3 id="二、Object-Based-基于对象-和-Object-Oriented-面向对象"><a href="#二、Object-Based-基于对象-和-Object-Oriented-面向对象" class="headerlink" title="二、Object Based(基于对象) 和 Object Oriented(面向对象)"></a>二、Object Based(基于对象) 和 Object Oriented(面向对象)</h3><p>Object Based：面对的是单一class的设计</p><p>Object Oriented: 面对的是多重classes的设计，classes和classes之间的关系</p><h3 id="三、Classes的两个经典分类"><a href="#三、Classes的两个经典分类" class="headerlink" title="三、Classes的两个经典分类"></a>三、Classes的两个经典分类</h3><p>1.不包含指针的class</p><p>2.包含指针的class</p><h3 id="四、C-代码的基本形式"><a href="#四、C-代码的基本形式" class="headerlink" title="四、C++代码的基本形式"></a>四、C++代码的基本形式</h3><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106201341460.png"><p>延伸文件名不一定是.h或.cpp，也可能是.hpp或其他或甚至无延伸名（看平台）。</p><h3 id="五、头文件"><a href="#五、头文件" class="headerlink" title="五、头文件"></a>五、头文件</h3><h4 id="1-头文件中的防卫式声明"><a href="#1-头文件中的防卫式声明" class="headerlink" title="1.头文件中的防卫式声明"></a>1.头文件中的防卫式声明</h4><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106201645597.png"><p>程序第一次include时，如果没有定义过_ COMPLEX _，就定义，否则不进入这个头文件内容。</p><p>因为可能很多程序都会用到这个头文件，使用防卫式声明的目的就是避免重复引入。</p><h4 id="2-头文件的布局"><a href="#2-头文件的布局" class="headerlink" title="2.头文件的布局"></a>2.头文件的布局</h4><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106202302500.png"><h3 id="六、类的声明和定义"><a href="#六、类的声明和定义" class="headerlink" title="六、类的声明和定义"></a>六、类的声明和定义</h3><h4 id="1-类模板template"><a href="#1-类模板template" class="headerlink" title="1.类模板template"></a>1.类模板template</h4><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106202644398.png"><p>template的作用是在类声明的时候不完全写死一些类型，而是在创建对象的时候指定类型。这样的好处是类更通用。</p><h4 id="2-inline（内联）函数"><a href="#2-inline（内联）函数" class="headerlink" title="2.inline（内联）函数"></a>2.inline（内联）函数</h4><p>C&#x2F;C++为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 <strong>inline</strong> 修饰符，表示为内联函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">num_check</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (v % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;奇&quot;</span> : <span class="hljs-string">&quot;偶&quot;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%02d   %s\n&quot;</span>, i, <span class="hljs-built_in">num_check</span>(i));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>for循环中num_check(i)会被替换为 <strong>(i%2&gt;0)?”奇”:”偶”，</strong>这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。</p><p>函数如果在类体中定义完成，就可能是inline函数（是否是inline函数得看编译器，有些复杂的函数编译器无法将其转为inline函数）。</p><p>如果函数在类体中声明，在类外定义，也可以在定义该函数时，在该函数前面加inline关键字；告诉编译器尽量将其转为inline函数。</p><h4 id="3-访问级别"><a href="#3-访问级别" class="headerlink" title="3.访问级别"></a>3.访问级别</h4><p><strong>public</strong>: 公有，外界可以通过类对象的成员访问符访问</p><p><strong>private</strong>: 私有，外界无法直接通过类对象的成员访问符来访问</p><p><strong>protected</strong>:</p><h4 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a>4.构造函数</h4><p>在创建对象时，会自动调用构造函数。</p><p><strong>构造函数的写法</strong>（2种）</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106204219284.png"><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106204244446.png"><p>默认实参不只是构造函数可以有，其他函数也可以这样写。</p><p><strong>初始值和初始列</strong>这种写法只有构造函数才有，写构造函数时也<strong>建议用这种写法</strong>，这种写法相比于赋值的写法<strong>效率高</strong>一些。</p><p><strong>函数重载-overloading</strong>，之所以可以重载，是因为函数编译后的实际名称并不是我们所写的那个函数名，而是加了对形参，返回值等的编码构成的函数名。</p><p><strong>构造函数可以有很多个</strong>，但是要注意，在下面这种情况下不能共存</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106205335963.png"><p>即其中1的构造函数有默认实参且默认实参和2相同，就不能有2这个构造函数。因为在创建对象时，如果没有实参，编译器不知道要调用哪个构造函数。</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106205603150.png"><p><strong>构造函数放在private的情况</strong></p><p>​单例模式</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106213349457.png"><p>​使用</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106213424665.png"><h4 id="6-常量成员函数"><a href="#6-常量成员函数" class="headerlink" title="6.常量成员函数"></a>6.常量成员函数</h4><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106213539023.png"><p>不改变数据的函数</p><p>如果不加const，在下面这种情况会报错</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106213816238.png"><h4 id="7-参数传递（值传递和引用传递）"><a href="#7-参数传递（值传递和引用传递）" class="headerlink" title="7.参数传递（值传递和引用传递）"></a>7.参数传递（值传递和引用传递）</h4><p>引用传递的速度和指针传递差不多，效率一般比值传递高，所以尽量传引用。如果不希望对方改，可以加const</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106214438844.png"><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106214633225.png"><p>operator表示操作符重载，operator +&#x3D; 表示重载+&#x3D;操作符</p><h4 id="8-返回值传递（值传递和引用传递）"><a href="#8-返回值传递（值传递和引用传递）" class="headerlink" title="8.返回值传递（值传递和引用传递）"></a>8.返回值传递（值传递和引用传递）</h4><p>尽量采用引用传递</p><h4 id="9-友元（friend）"><a href="#9-友元（friend）" class="headerlink" title="9.友元（friend）"></a>9.友元（friend）</h4><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106214841223.png" alt="image-20240106214841223"><p>友元函数可以自由取得private的成员变量</p><p>友元打破了封装</p><p><strong>相同class的各个对象互为友元</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106215228589.png"><h4 id="10-什么时候可以使用引用传递，什么时候可以返回引用"><a href="#10-什么时候可以使用引用传递，什么时候可以返回引用" class="headerlink" title="10.什么时候可以使用引用传递，什么时候可以返回引用"></a>10.什么时候可以使用引用传递，什么时候可以返回引用</h4><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106215952659.png"><p>如果return的变量是在函数内部创建的，就不能使用引用返回，因为局部变量在函数结束时会自动销毁。</p><h4 id="11-操作符重载（成员函数，有this）"><a href="#11-操作符重载（成员函数，有this）" class="headerlink" title="11.操作符重载（成员函数，有this）"></a>11.操作符重载（成员函数，有this）</h4><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106220712257.png"><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106220615083.png"><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106220722692.png"><p>this不一定要显式写出。</p><p><strong>返回引用时，传递者无需知道接收者是以引用形式接收</strong>，return时把值return出去。如果是指针，要把指针指向的object return出去</p><p>上面的operator +&#x3D;返回值可以是void吗？如果是void会有问题，比如使用下面这个连续+&#x3D;的时候会出错</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106221631127.png"><h4 id="12-操作符重载（非成员函数，无this）"><a href="#12-操作符重载（非成员函数，无this）" class="headerlink" title="12.操作符重载（非成员函数，无this）"></a>12.操作符重载（非成员函数，无this）</h4><p>全局函数，不能return引用，因为返回的是在函数内部创建的</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106223314919.png"><p><strong>&lt;&lt;不能使用成员函数的方法重载</strong>，因为&lt;&lt;作用于cout，而cout是多年前就已经写好的，是ostream类型</p><h4 id="13-临时对象-typename"><a href="#13-临时对象-typename" class="headerlink" title="13.临时对象 typename();"></a>13.临时对象 typename();</h4><p>如上图的complex(real(x)+y, imag(x));创建了complex的临时对象</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106223710328.png"><p>黄色部分为临时对象</p><h4 id="14-拷贝构造、拷贝赋值、析构函数"><a href="#14-拷贝构造、拷贝赋值、析构函数" class="headerlink" title="14.拷贝构造、拷贝赋值、析构函数"></a>14.拷贝构造、拷贝赋值、析构函数</h4><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106232206553.png"><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106232358570.png"><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106233010122.png"><p><strong>有指针成员的类一定要有拷贝构造和拷贝赋值</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106232717520.png"><p><strong>一定要在拷贝赋值中检查是否自我赋值</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106233208606.png"><h3 id="七、堆、栈与内存管理"><a href="#七、堆、栈与内存管理" class="headerlink" title="七、堆、栈与内存管理"></a>七、堆、栈与内存管理</h3><h4 id="1-栈（stack）"><a href="#1-栈（stack）" class="headerlink" title="1.栈（stack）"></a>1.栈（stack）</h4><p>stack是存在于某作用域的一块内存空间。例如当你调用函数，函数本身即会形成一个stack用来放置它所接收的参数，以及返回地址，在函数本体内声明的非static变量，其所使用的内存块都取自stack</p><p><strong>栈中对象的生命周期</strong>：离开作用域就会自动销毁。</p><h4 id="2-堆（heap）"><a href="#2-堆（heap）" class="headerlink" title="2.堆（heap）"></a>2.堆（heap）</h4><p>heap是指由操作系统提供的一块全局内存空间，程序可动态分配从其中获得若干区块。</p><p>常见的动态分配堆内存的方式，malloc、new</p><p>从堆中申请的内存要手动释放</p><p><strong>堆中对象的生命周期</strong>：如果用new申请的，在delete之后结束，如果是用malloc申请的，free之后结束</p><p>使用new时，编译器的执行步骤是先分配内存，再调用构造函数</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106234835269.png"><p>使用delete时，先调用析构函数，再释放内存</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106235042683.png"><p><strong>在VC中动态分配内存时具体得到的内存块</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240106235426565.png"><p>除了Complex对象所占的8个字节之外，还额外分配了一些内存，红色部分是cookie（记录整块的大小），灰色部分是调试模式下分配的内存块，每格4个字节。因为在VC下分配的内存必须是16的倍数，所以增加了三个pad填充（青色部分），最后分配的内存大小是52+12&#x3D;64字节。</p><p>64的16进制表示为40，cookie是41，其中1表示的是这块内存操作系统分配出去了</p><p>在非调试模式下</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107000123956.png"><p><strong>VC中动态分配所得的数组内存分配情况</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107000737705.png"><p>灰色部分是Complex，除了上面介绍的外，还会增加一个内存块还记录数组的元素个数</p><p><strong>array new一定要用array delete</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107001245258.png"><h3 id="八、静态（static）"><a href="#八、静态（static）" class="headerlink" title="八、静态（static）"></a>八、静态（static）</h3><p>静态函数没有this</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107154531799.png"><p>静态数据成员要在类外部定义，非静态数据成员不能在类外部定义。</p><p><strong>单例模式的设计</strong></p><p>这种方式不允许外界来创建对象，但是把static A a放在声明里有个缺点是如果没用到这个类也会占用内存</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107155440114.png"><p>更优的方式</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107155651445.png"><h3 id="九、函数模板template"><a href="#九、函数模板template" class="headerlink" title="九、函数模板template"></a>九、函数模板template</h3><p>和类模板不同在于函数模板不用显式的指出类型，编译器会对函数模板进行自动推导</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107160244955.png"><h3 id="十、命名空间namespace"><a href="#十、命名空间namespace" class="headerlink" title="十、命名空间namespace"></a>十、命名空间namespace</h3><p>可以防止重名，将所有东西放在一个namespace里面</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107160444028.png"><p>命名空间的使用，三种方式</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107160543652.png"><h3 id="十一、类与类之间的关系（Composition、Delegation、Inheritance）"><a href="#十一、类与类之间的关系（Composition、Delegation、Inheritance）" class="headerlink" title="十一、类与类之间的关系（Composition、Delegation、Inheritance）"></a>十一、类与类之间的关系（Composition、Delegation、Inheritance）</h3><h4 id="1-Composition-组合-，表示has-a"><a href="#1-Composition-组合-，表示has-a" class="headerlink" title="1.Composition(组合)，表示has-a"></a>1.Composition(组合)，表示has-a</h4><p>类和类之间的关系，一个类里面有另一个类的变量</p><p><strong>适配模式</strong>Adapter</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107161102136.png"><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107161348118.png"><p><strong>Composition关系下的构造和析构</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107161533512.png"><p><strong>构造由内而外</strong></p><p>Container的构造函数首先调用Component的default构造函数，然后才执行自己</p><p><strong>析构由外而内</strong></p><p>Container的析构函数首先执行自己的析构函数，然后才调用Component的析构函数</p><h4 id="2-Delegation-委托"><a href="#2-Delegation-委托" class="headerlink" title="2.Delegation(委托)"></a>2.Delegation(委托)</h4><p>通过指针连接，和Composition的区别在于委托是通过指针连接，连接的两个类生命周期不一样</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107162121475.png"><p>可以使用引用计数</p><h4 id="3-Inheritance-继承-，表示is-a"><a href="#3-Inheritance-继承-，表示is-a" class="headerlink" title="3.Inheritance(继承)，表示is-a"></a>3.Inheritance(继承)，表示is-a</h4><p>is-a：是一种，比如小轿车是一种车</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107162825563.png"><p><strong>继承关系下的构造和析构</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107163103502.png"><p>父类的构造函数必须是virtual函数（虚函数）</p><p><strong>构造由内而外</strong></p><p>子类的构造函数首先调用父类的default构造函数，然后才执行自己</p><p><strong>析构由外而内</strong></p><p>子类的析构函数首先执行，再调用父类的析构函数</p><h4 id="4-Inheritance-Composition"><a href="#4-Inheritance-Composition" class="headerlink" title="4.Inheritance + Composition"></a>4.Inheritance + Composition</h4><p><strong>继承和组合关系下的构造和析构</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107170509728.png"><p>第一种情况</p><p>构造函数调用顺序：Base-Component-Derived</p><p>析构函数调用顺序：Derived-Component-Base</p><p>第二种情况</p><p>构造函数调用顺序：Component-Base-Derived</p><p>析构函数调用顺序：Derived-Base-Component</p><h4 id="5-Delegation-Inheritance"><a href="#5-Delegation-Inheritance" class="headerlink" title="5.Delegation + Inheritance"></a>5.Delegation + Inheritance</h4><p>功能最强大的组合。</p><p>可以解决的问题</p><p>一份数据，多种不同呈现方式的场景，改变数据时，所有相关呈现方式的内容也跟着变</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107171159493.png"><p><strong>设计模式之观察者模式</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107171425971.png"><p><strong>设计模式之组合模式</strong></p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107172511693.png"><p><strong>设计模式之原型模式</strong></p><p>创建未来的class</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107173044794.png"><h3 id="十四、虚函数"><a href="#十四、虚函数" class="headerlink" title="十四、虚函数"></a>十四、虚函数</h3><p>非虚函数：不希望子类重新定义（override，覆写）它</p><p>虚函数：希望子类重新定义（override，覆写）它， 它已有默认定义</p><p>纯虚函数（pure virtual）：希望子类一定要重新定义（override，覆写）它（子类不重新定义会报错），它一般没有默认定义(但可以有默认定义)</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107163714502.png"><p><strong>设计模式之模版模式</strong></p><p>父类方法中一些函数内部调用函数的实现由子类来实现</p><img src="/2024/01/07/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/image-20240107164211269.png">]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年</title>
    <link href="/2024/01/06/2024%E5%B9%B4/"/>
    <url>/2024/01/06/2024%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="2024年"><a href="#2024年" class="headerlink" title="2024年"></a>2024年</h1><h3 id="一、50本书计划"><a href="#一、50本书计划" class="headerlink" title="一、50本书计划"></a>一、50本书计划</h3><p>不知道多久没看除专业技术之外的书了，心里感觉到莫名的空虚，精神世界也开始变得荒芜。始终认为精神是抵抗一切挫折的源力，为此，借2024年伊始，定下50本书计划，希望慢慢丰富自己的精神世界。</p><p><strong>《鲛在水中央》</strong>  孙频               2024年1月6日读完</p><p><strong>《盐》</strong> 孙频                               在读…</p><p>持续更新中…</p>]]></content>
    
    
    <categories>
      
      <category>计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>问心-关于年龄</title>
    <link href="/2024/01/05/%E9%97%AE%E5%BF%83-%E5%85%B3%E4%BA%8E%E5%B9%B4%E9%BE%84/"/>
    <url>/2024/01/05/%E9%97%AE%E5%BF%83-%E5%85%B3%E4%BA%8E%E5%B9%B4%E9%BE%84/</url>
    
    <content type="html"><![CDATA[<h1 id="问心-关于年龄"><a href="#问心-关于年龄" class="headerlink" title="问心-关于年龄"></a>问心-关于年龄</h1><p>从转行读研到如今临近毕业，一直在为年龄的问题焦虑。我知道焦虑是没用的，但是一旦发生一些事情触及到年龄时（比如校招因为年龄被卡（可能），选调年龄超限（虽然也没有很强的意愿参加选调），认识的人对我在该成家立业的年纪却选择转行读研的质疑），总是会感到焦虑和痛苦。</p><p><strong>我焦虑和痛苦的真正来源是什么？</strong></p><p>一是因为年龄问题对自己未来的担心。担心因为年龄问题找不到工作，担心找到了工作，最后因为年龄问题没做多久就面临失业，也担心到了一定的年龄需要承担该年龄所需要的压力和责任时，自己却还准备好。</p><p>二是来源于比较。和同龄人相比，他们多数已经成家立业，完成了世俗赋予这个年龄的人生任务，而自己却远远地掉了队。和现在的同学相比，他们年轻，有着很高的下限以及试错的机会，而我已没有容错。</p><p><strong>我好像是给自己套上了层层的枷锁。</strong></p><p>我应该也必须意识到年龄所带来的问题，在意识到这些问题时，我最应该关注的是<strong>“如何避免这些问题的发生”</strong>，而不是过分地陷入<strong>“当这个问题发生了，我该怎么办？”</strong>的漩涡之中。对于还没有发生的事，如果总是以<strong>悲观者的心态</strong>去担心它可能发生，发生了我会多难受。这只会徒增精神内耗，阻碍着自己的发展。</p><p><strong>比较是偷走幸福的贼。</strong>如果不能以正确的心态去面对差距，就不应该去比较。所谓正确的心态是看到差距时，<strong>坦然</strong>去接受它，有必要时努力去弥补差距。但做到<strong>”坦然“</strong>是很难的，比较常常会使我们的心理产生扭曲，对自己产生错误的认知，会觉得你也应该和他们一样或者不应该有这么大的差距，从而产生焦虑，挫败甚至抱怨等负面情绪。所以，在无法以正确的心态去面对差距时，我们应该转移我们的视线，多去关注自己的内心。</p><p><strong>时间是单向的，过去的一切和现在的一切都已成既定的事实，无法改变。</strong></p><p>我因为年龄而焦虑，那就应该更加珍惜时间。<strong>把我的每一分每一秒都用在有价值的事情上。</strong>但是扪心自问，我并没有做到。回顾过去，我浪费了太多的时间，浪费了太多的时间在无谓的焦虑和没有价值的思考上，浪费了太多的时间在刷手机上，浪费了太多的时间在因为纠结而忽左忽右的错误行动上。</p><p>要时刻提醒自己，时间是宝贵的。年龄的焦虑也是对时间的焦虑，当所有的时间或者大部分的时间都用在有价值的事情上，也就没有必要焦虑了。</p>]]></content>
    
    
    <categories>
      
      <category>人生感悟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人生感悟</tag>
      
      <tag>问心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/01/05/C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E%EF%BC%88CRT%20Startup%20code%EF%BC%89/"/>
    <url>/2024/01/05/C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E%EF%BC%88CRT%20Startup%20code%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C-程序的生前死后（CRT-Startup-code）"><a href="#C-程序的生前死后（CRT-Startup-code）" class="headerlink" title="C++程序的生前死后（CRT Startup code）"></a>C++程序的生前死后（CRT Startup code）</h1><h3 id="一、读前带入的问题"><a href="#一、读前带入的问题" class="headerlink" title="一、读前带入的问题"></a>一、读前带入的问题</h3><p>1.C++进入点是main()吗？</p><p>2.什么代码比main()更早被执行？</p><p>3.什么代码在main()结束后才被执行？</p><p>4.为什么上述代码可以如此行为？</p><p>5.Heap的结构如何？</p><p>6.I&#x2F;O的结构如何？</p><h3 id="二、参考书籍"><a href="#二、参考书籍" class="headerlink" title="二、参考书籍"></a>二、参考书籍</h3><p>《程序员的自我修养——链接、装载与库》</p><h3 id="三、什么是CRT-Startup-code"><a href="#三、什么是CRT-Startup-code" class="headerlink" title="三、什么是CRT Startup code"></a>三、什么是CRT Startup code</h3><p><strong>CRT Startup code</strong>：C Runtime Startup code。启动码函数。</p><p>任何C&#x2F;C++程序在main函数之前有个启动码函数，main函数是在启动码函数里面调用，启动码函数是最早执行的函数</p><h4 id="1-Startup-code的位置（以window环境下vc6为例）"><a href="#1-Startup-code的位置（以window环境下vc6为例）" class="headerlink" title="1.Startup code的位置（以window环境下vc6为例）"></a>1.Startup code的位置（以window环境下vc6为例）</h4><p>在window环境下的VC6中的CRT Startup code函数名为mainCRTStartup()。位于crt0.c文件中</p><p><strong>call stack(调用栈)</strong></p><img src="/2024/01/05/C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E%EF%BC%88CRT%20Startup%20code%EF%BC%89/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231229161058533.png" alt="image-20231229161058533" style="zoom:50%;"><p>KERNEL32! bff89f5b()…内核函数</p><p>mainCRTStartup() 启动码函数</p><h3 id="四、Startup-Code执行流程"><a href="#四、Startup-Code执行流程" class="headerlink" title="四、Startup Code执行流程"></a>四、Startup Code执行流程</h3><img src="/2024/01/05/C++%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%89%8D%E6%AD%BB%E5%90%8E%EF%BC%88CRT%20Startup%20code%EF%BC%89/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20231229155015427.png" alt="image-20231229155015427" style="zoom:67%;"><p>1）内存初始化</p><p>2）IO初始化</p><p>3）4）5）6）字符串处理</p><p>7）c data 初始化</p><p>8）main</p><p>9）exit：C++程序执行完后的后处理</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>左耳听风文章阅读笔记-高效沟通篇</title>
    <link href="/2023/12/27/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E7%AF%87/"/>
    <url>/2023/12/27/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="左耳听风文章阅读笔记-高效沟通篇"><a href="#左耳听风文章阅读笔记-高效沟通篇" class="headerlink" title="左耳听风文章阅读笔记-高效沟通篇"></a>左耳听风文章阅读笔记-高效沟通篇</h1><h3 id="一、沟通的原理和问题"><a href="#一、沟通的原理和问题" class="headerlink" title="一、沟通的原理和问题"></a>一、沟通的原理和问题</h3><p>沟通的本质和通信原理类似，说话的人相当于将信息进行编码，听者将听到的信息进行解码。</p><img src="/2023/12/27/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%AB%98%E6%95%88%E6%B2%9F%E9%80%9A%E7%AF%87/image-20231227125510266.png"><p>理解错误通常是由于每个人的编码器和解码器不匹配造成的。解决方案：约定、反馈、共识。</p><p>信息传递的层数越深，信息丢失就越大，所以信息传递过程中将信息源头的信息原模原样分享出去是必要的。</p><h3 id="二、沟通阻碍和应对方法"><a href="#二、沟通阻碍和应对方法" class="headerlink" title="二、沟通阻碍和应对方法"></a>二、沟通阻碍和应对方法</h3><h4 id="1-信息不准确"><a href="#1-信息不准确" class="headerlink" title="1.信息不准确"></a>1.信息不准确</h4><p>在信息不准确时，节约时间已经没有意义了。<strong>沟通效率的关键不在于快，而是准确</strong>！</p><p>在沟通之前，首先要想清楚沟通的目的是什么，然后整理自己的措辞。如果是一些比较重要的沟通，最好可以把自己的想法写下来，然后放一会儿，再回过头来看，想象一下如果是别人对自己讲这些话，自己会怎么理解。</p><h4 id="2-信息太多"><a href="#2-信息太多" class="headerlink" title="2.信息太多"></a>2.信息太多</h4><p><strong>不要绕弯子，有话直说，这是最高效的沟通方式。这既是对对方的一种信任，也是一种对自己的尊重。这样沟通，事情往往能得到更好的解决</strong>。</p><p>避免太多无效信息和干扰信息：</p><p>​1）害怕别人可能不能理解，就进行大量的前期铺垫和背景描述；</p><p>​2）害怕得罪别人，先花大量的时间进行解释和免责；</p><p>​3）想把所有的东西都告诉对方，在做 PPT 的时候，放入了大量的文字而让人 get 不到重点；</p><p>​4）怕别人听不进去，唠唠叨叨，车轱辘话来回说；</p><p>​5）用各种各样的比喻来说明一个事，但就是不直接说明这个事，把大家搞得云里雾里的；</p><p>​6）枝节太多，跑题，东拉西扯，抓不住重点；</p><h4 id="3-没有交互"><a href="#3-没有交互" class="headerlink" title="3.没有交互"></a>3.没有交互</h4><p>沟通中的一方或者双方喋喋不休地说，而且是只说不听，各说各的。这样不仅会把双方都搞得很疲倦，而且问题一点儿也没有解决。这样的沟通可以说是完全失败的，只是在浪费时间。遇到这种情况，一定要学会止损。</p><p><strong>找到对方的兴趣点，降低表达自己真实想法的门槛，培养让大家畅所欲言的自由环境，把自己的答案变成问题，让其它人有参与感，这样才可能有好的沟通，也能够有好的结果</strong>。</p><h4 id="4-表达方式"><a href="#4-表达方式" class="headerlink" title="4.表达方式"></a>4.表达方式</h4><p>很多场景下，人们以一种平等且互相尊重的态度进行交流的时候，沟通一般都能得到顺利进行。</p><p>很多时候沟通失败，不是沟通内容出了问题，是表达方式、谈话的态度出了问题。</p><h4 id="5-二手信息"><a href="#5-二手信息" class="headerlink" title="5.二手信息"></a>5.二手信息</h4><p><strong>到信息的源头，向当事人去求证，会让这个世界更加和谐，也会让你变得更有智慧</strong>。</p><h4 id="6-信道被黑"><a href="#6-信道被黑" class="headerlink" title="6.信道被黑"></a>6.信道被黑</h4><p>信息不对称只有短期利益，没有长期利益。短期来看，团队成员听话，团队好管理。但长远来看，这么做无疑是在剥夺员工自我成长的机会，从而无法培养员工的自驱性和创造力。</p><h3 id="三、沟通方式和技巧"><a href="#三、沟通方式和技巧" class="headerlink" title="三、沟通方式和技巧"></a>三、沟通方式和技巧</h3><h4 id="1-沟通方式"><a href="#1-沟通方式" class="headerlink" title="1.沟通方式"></a>1.沟通方式</h4><p>​<strong>1）尊重</strong></p><p>​我可以不同意你，但是会捍卫你说话的权利。</p><p>​赢得对方的尊重需要先尊重对方。</p><p>​<strong>一定要和对方有观点上的交互，甚至是碰撞。沟通的目的不是为了附和对方，而是产生一种更完整更全面的认知</strong>。只有当双方都愿意接受不同的观点时，此时的沟通才会迸发出更多的火花，而这一切都需要发生在相互尊重的基础之上。</p><p>​<strong>2）倾听</strong></p><p>​倾听与听或者听到有很大不同，它是解读别人所说信息的过程，包含听到、专注、理解、回应和记忆五大元素。</p><p>​一定要学会倾听，掌握到更多的信息，因为掌握不了足够的信息就会信息不对称，信息不对称就会做出错误的假设。</p><p>​<strong>3）情绪控制</strong></p><p>​<strong>不要过早或者过度打岔和反驳</strong>。</p><p>​<strong>求同存异，冷静客观</strong>。</p><p>​<strong>切莫在冲动之下，说出很多一些过分或过激的话，因为言语的力量是巨大的，杀伤力有时难以预估</strong>。</p><p>​<strong>有时候，我会自己告诫自己，情绪是自己的，不是别人的，不应该被别人 hack 了</strong>。</p><h4 id="2-沟通技巧"><a href="#2-沟通技巧" class="headerlink" title="2.沟通技巧"></a>2.沟通技巧</h4><p>​<strong>1）引起对方的兴趣</strong></p><p>​<strong>2）直达主题，强化观点</strong></p><p>​过滤掉无用或者非关键信息的能力很重要。<strong>确定自己的目标，学会抓重点，知道自己要什么和不要什么，这样你要的才会更鲜明。当一些事情变得简明和鲜明起来时，你才会表现出有力量的观点和话语。而这些被强化过的观点和话语，只需要一句，就会在对方脑子里形成一个小爆点，要么击中了对方的软处（扎心），要么会让对方产生深度思考。</strong></p><p>​<strong>3）基于数据和事实</strong></p><p>​在很多时候，我们要在沟通之前注意收集相关的数据和事实，多做一些沟通相关的功课，你的沟通会更有效率。基本上来说，数据、事实、证据和权威是沟通中的大规模杀伤性武器！</p><h3 id="四、沟通技术"><a href="#四、沟通技术" class="headerlink" title="四、沟通技术"></a>四、沟通技术</h3><h4 id="1-逻辑"><a href="#1-逻辑" class="headerlink" title="1.逻辑"></a>1.逻辑</h4><p>逻辑是一门科学，也是一门数学。谁是谁的充分条件、必要条件或充要条件，以及有没有关联关系，有没有因果关系等，这些东西你要做到心中有数，当对方的表达中出现逻辑错误时，你可以随时指出来。</p><h4 id="2-信息"><a href="#2-信息" class="headerlink" title="2.信息"></a>2.信息</h4><p>信息要全面、准确。这里重点提一下 X&#x2F;Y 问题。X&#x2F;Y 问题是一件非常讨厌的事情。有时候我们拿着 Y 问题去找别人，问到一半才知道，我们原来要问的是 X 问题。</p><p><strong>要解的真实问题才是 X 问题，手段都是 Y 问题。</strong></p><h4 id="3-维度"><a href="#3-维度" class="headerlink" title="3.维度"></a>3.维度</h4><p>如果你要找不同就要到细节上去，如果你要找共同，就要到大局上去。</p><p>在和人争论时，如果要反驳，那一定是低维度反驳，越细节越好。而在说服对方时，则要在高维度说服对方，越宏观越好，比如从公司的大目标出发。高维度讲究的是求同存异。你跟别人相同的东西一定是高维度的，这就是大同，而你跟别人不同的一定是非常细节的东西。大同的东西，更容易让人产生共鸣，从而容易达成默契和共识。</p><p><strong>能够站在更高的维度来沟通是我们需要努力的目标</strong>。</p><h4 id="4-共同"><a href="#4-共同" class="headerlink" title="4.共同"></a>4.共同</h4><p>共情，共享，共利，共识以及换位思考。如果你能站在对方的角度思考问题，那么你所想的问题以及所想沟通的内容，一定会跟只想自己有很大不同。同时，你会神奇地发现，换位思考能帮助你更为全面地理解并解决问题。</p><p>从高维度，寻找共同之处。</p><h4 id="5-三本书"><a href="#5-三本书" class="headerlink" title="5.三本书"></a>5.三本书</h4><p>《<a href="https://book.douban.com/subject/26871359/">清醒思考的艺术</a>》、《<a href="https://book.douban.com/subject/24754537/">简单逻辑学</a>》和《<a href="https://book.douban.com/subject/5320866/">重来</a>》。</p><h3 id="五、善于提问"><a href="#五、善于提问" class="headerlink" title="五、善于提问"></a>五、善于提问</h3><h4 id="1-引导"><a href="#1-引导" class="headerlink" title="1.引导"></a>1.引导</h4><p>作为 Leader，你要记住，<strong>永远不要给员工答案，要让员工给你答案，而且不要只给一个答案，一定要给多个答案</strong>。然后让他们比较这些答案，促使他们深入地进行思考。这不是在让员工做问答题，其实是在给员工成长机会，促进他们的成长。</p><h4 id="2-倾听"><a href="#2-倾听" class="headerlink" title="2.倾听"></a>2.倾听</h4><p>倾听意味着在听他人讲话的时候，不让自己的想法扭曲别人传递的信息。你要做到毫无偏见，才能全面理解对方的信息。倾听不只是听或者听见，需要你用心聆听别人讲话，而不是只听自己想听到的内容。</p><h4 id="3-共情"><a href="#3-共情" class="headerlink" title="3.共情"></a>3.共情</h4><p>共情，又被称为同理心，或者换位思考，它指的是站在对方立场设身处地思考问题的一种方式。换句话说，在人际交往过程中，你需要能够体会他人的情绪和想法、理解他人的立场和感受，并站在他人的角度思考和处理问题。</p><p>一定要站在对方的角度来思考问题，理解对方，真心对对方好。晓之以理，动之以情。</p><h4 id="4-高维"><a href="#4-高维" class="headerlink" title="4.高维"></a>4.高维</h4><p>员工来跟你聊的，通常都是细节问题。</p><p>作为管理者，你应该知道，没有完美的公司，任何公司都存在这样那样的问题。你需要有更高的维度来看待这个问题，来给员工做出解释，让他们既能理解公司的决定，又能保持动力转到新的方向上。</p><h4 id="5-反馈"><a href="#5-反馈" class="headerlink" title="5.反馈"></a>5.反馈</h4><p><strong>“1-2-3 反馈机制”</strong></p><p>​1）不管你遇到什么问题，如果自己在那儿憋一个小时找不到解决方案，或者说没有任何思路，就要反馈到高级工程师这边来。</p><p>​2）如果跟高级工程师在一起两个小时内，找不到任何解决方案或者没有思路，那么就要反馈到一线 leader。</p><p>​3）如果一线 leader、高级工程师，花了三个小时，依然找不到方案，那么这个事就可能是个大事了，要向上级反馈了。</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>YFCC100M和SUN3D数据集提取代码分析</title>
    <link href="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="YFCC100M和SUN3D数据集提取代码分析"><a href="#YFCC100M和SUN3D数据集提取代码分析" class="headerlink" title="YFCC100M和SUN3D数据集提取代码分析"></a>YFCC100M和SUN3D数据集提取代码分析</h1><h3 id="一、数据集结构"><a href="#一、数据集结构" class="headerlink" title="一、数据集结构"></a>一、数据集结构</h3><p><strong>1.字段</strong></p><p>​<strong>1）’xs’：</strong>初始匹配对的归一化平面坐标:</p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/69910bfaa6af2645824ca4a1ff8f7a9c.svg"><p>​<strong>2）’ys’：</strong>通过相机外参计算得到基础矩阵，然后计算所有匹配对在基础矩阵作用下偏差。正确的匹配对有如下关系:</p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20231226153509842.png"><p>如果不是正确匹配对的话，在基础矩阵F作用下值不为0，实际的代码中最后的结果进行了平方操作和归一化操作，所以ys的值全部是大于等于0的。</p><p>​<strong>3）’Rs’：</strong>两个图像对的相对旋转矩阵</p><p>​<strong>4） ‘ts’：</strong>两个图像对的相对平移向量</p><p>​<strong>5）’ratios’：</strong>计算描述子相似度时，每个特征点与其他特征点的描述符之间最小的欧式距离和第二小的欧式距离之比</p><p>​<strong>6） ‘mutuals’：</strong>是否互为最匹配点</p><p>​<strong>7） ‘cx1s’：</strong>表示图像1坐标原点到像素坐标原点在x轴方向的位移（单位为像素），图像坐标原点默认在图像中心，而像素坐标原点在左上角</p><p>​<strong>8）’cy1s’：</strong>表示图像1坐标原点到像素坐标原点在y轴方向的位移（单位为像素），图像坐标原点默认在图像中心，而像素坐标原点在左上角</p><p>​<strong>9）’f1s’：</strong>表示图像1的两个相机内参$f_x$和$f_y$，其中 $f_x$&#x3D; $\alpha f$,其中$\alpha$是图像坐标系x轴每单位代表的像素数，$f$表示焦距，$f_y$同理。</p><p>​<strong>10）’cx2s’：</strong>表示图像2坐标原点到像素坐标原点在x轴方向的位移（单位为像素），图像坐标原点默认在图像中心，而像素坐标原点在左上角</p><p>​<strong>11）’cy2s’：</strong>表示图像2坐标原点到像素坐标原点在y轴方向的位移（单位为像素），图像坐标原点默认在图像中心，而像素坐标原点在左上角</p><p>​<strong>12）’f2s’：</strong>表示图像2的两个相机内参$f_x$和$f_y$，其中 $f_x$&#x3D; $\alpha f$,其中$\alpha$是图像坐标系x轴每单位代表的像素数，$f$表示焦距，$f_y$同理。</p><p>​</p><h3 id="二、代码执行总体流程"><a href="#二、代码执行总体流程" class="headerlink" title="二、代码执行总体流程"></a>二、代码执行总体流程</h3><p><strong>1.提取特征点和对应的描述子</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python extract_feature.py<br></code></pre></td></tr></table></figure><p>会为每张图片生成一个hdf5文件（类似字典格式），文件里面存储的是该图片的所有特征点[‘kepoints’]及其描述子[‘descriptors’]</p><p><strong>2.生成dataset</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python yfcc.py<br></code></pre></td></tr></table></figure><p><strong>调用过程</strong></p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20231226234000625.png" alt="image-20231226234000625" style="zoom:50%;"><p><strong>2.1.构建图片对</strong></p><p>在sequence.py文件中的Sequence类初始化过程中构建(dataset.py—&gt;self.dump_data()–&gt;dataset&#x3D;Sequence())。在每个场景的图片中根据visibility.txt中的能见度阈值挑选出能见度大于指定阈值（50）的图片进行两两配对。在每个场景中随机选取指定数量的图片对。</p><p><strong>2.2.特征点匹配</strong></p><p>dataset.py—&gt;self.dump_data()–&gt;dataset&#x3D;Sequence()–&gt;dataset.dump_intermediate()</p><p>构建完图片对后，对每个图片对的特征点采用最近邻算法进行特征点匹配。得到<strong>idx_sort、ratio_test、mutual_nearest</strong>，存储到h5文件中。</p><p><strong>idx_sort</strong>:包含两个数组，第一个数组为图片1中特征点编号，第二个数组为与图片1特征点最近的图片2的特征点编号</p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/1665576292447-3fe423ae-fa84-4abc-b7b2-38a0b78e39e4.png"><p><strong>mutual_nearest</strong>:表示是否是互最近邻的数组，0代表不是互最近邻，1代表是互最近邻</p><p><strong>ratio_test</strong>:最近邻与次近邻欧式距离比</p><p><strong>2.3.保存数据</strong></p><p>dataset.py—&gt;self.dump_data()–&gt;dataset&#x3D;Sequence()–&gt;dataset.dump_datasets()</p><p>通过self.make_xy()接口来获取需要的字段信息。</p><p>所有字段信息分开保存为pkl文件，比如xs字段，每个场景保存一个xs.pkl文件</p><p><strong>2.4.所有场景的数据存入一个h5py文件中</strong></p><p>dataset.py—&gt;self.dump_data()–&gt;self.collect()</p><p><strong>h5py文件结构</strong></p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20231226232629013.png"><p>每个group代表一个字段，group里面的每个dataset表示每对图片对的字段信息</p><h3 id="三、代码结构"><a href="#三、代码结构" class="headerlink" title="三、代码结构"></a>三、代码结构</h3><p><strong>1.代码文件</strong></p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20231226145926201.png"><p><strong>extract_feature.py</strong>：通过SIFT算法提取特征点和对应的描述子，生成hdf5文件存储每张图片的所有特征点和对应的描述子</p><p><strong>yfcc.py</strong>：生成yfcc100m的训练集、测试集和验证集</p><p><strong>dataset.py</strong>：被yfcc.py调用，用于生成dataset</p><p><strong>geom.py</strong>：处理相机内外参的接口，被sequence.py调用</p><p><strong>transformations.py</strong>：被geom.py调用，用于处理四元数</p><p><strong>sequence.py</strong>：提取图像对，计算图像对的相对的相机外参</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>图像匹配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像配准</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左耳听风文章阅读笔记-高效学习篇</title>
    <link href="/2023/12/25/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <url>/2023/12/25/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="左耳听风文章阅读笔记-高效学习篇"><a href="#左耳听风文章阅读笔记-高效学习篇" class="headerlink" title="左耳听风文章阅读笔记-高效学习篇"></a>左耳听风文章阅读笔记-高效学习篇</h1><h3 id="一、端正学习态度"><a href="#一、端正学习态度" class="headerlink" title="一、端正学习态度"></a>一、端正学习态度</h3><p>学习是一件“逆人性”的事，就像锻炼身体一样，<strong>需要人持续付出，会让人感到痛苦，并随时想找理由放弃</strong>。</p><h4 id="1-主动学习和被动学习"><a href="#1-主动学习和被动学习" class="headerlink" title="1.主动学习和被动学习"></a>1.主动学习和被动学习</h4><p><strong>学习金字塔</strong></p><img src="/2023/12/25/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20231225141950468.png" alt="image-20231225141950468" style="zoom:50%;"><p><strong>被动学习</strong>：听讲、阅读、视听、演示</p><p><strong>主动学习</strong>：讨论、实践、教授他人</p><p><strong>学习不是努力读更多的书，盲目追求阅读的速度和数量，这会让人产生低层次的勤奋和成长的感觉，这只是在使蛮力。要思辨，要践行，要总结和归纳，否则，你只是在机械地重复某件事，而不会有质的成长的。</strong></p><h4 id="2-浅度学习和深度学习"><a href="#2-浅度学习和深度学习" class="headerlink" title="2.浅度学习和深度学习"></a>2.浅度学习和深度学习</h4><p><strong>深度学习的关键</strong>：</p><p>​1）高质量的信息源和第一手的知识</p><p>​2）把知识连成地图，将自己的理解反述出来</p><p>​3）不断地反思和思辨，与不同年龄段的人讨论</p><p>​4）举一反三，并践行之，把知识转换成技能</p><p><strong>学习的三个步骤</strong>：</p><p>​1）知识采集</p><p>​2）知识缝合（将信息组织起来，形成结构体。连接记忆，逻辑推理，知识梳理）</p><p>​3）技能转换（举一反三，实践和练习以及传授教导）</p><h4 id="3-学习的目的"><a href="#3-学习的目的" class="headerlink" title="3.学习的目的"></a>3.学习的目的</h4><p>**学习是为了找到方法 ** 学习是为了找到通往答案的路径和方法，是为了拥有无师自通的能力。</p><p><strong>学习是为了找到原理</strong> 一旦理解和掌握了这些本质的东西，你就会发现，整个复杂多变的世界在变得越来越简单。你就好像找到了所有问题的最终答案似的，一通百通了。</p><p><strong>学习是为了了解自己</strong> 开拓眼界的目的就是发现自己的不足和上升空间，从而才能让自己成长。</p><p><strong>学习是为了改变自己</strong> 学习是为了改变自己的思考方式，改变自己的思维方式，改变自己与生俱来的那些垃圾和低效的算法。总之，学习让我们改变自己，行动和践行，反思和改善，从而获得成长。</p><h3 id="二、源头、原理和知识地图"><a href="#二、源头、原理和知识地图" class="headerlink" title="二、源头、原理和知识地图"></a>二、源头、原理和知识地图</h3><h4 id="1-挑选知识和信息源"><a href="#1-挑选知识和信息源" class="headerlink" title="1.挑选知识和信息源"></a>1.挑选知识和信息源</h4><p><strong>好信息源的特质</strong></p><p>1）应该是第一手资料，不是被别人理解过、消化过的二手资料。尤其对于知识性的东西来说，更是这样。应该是原汁原味的，不应该是被添油加醋的。</p><p>2）应该是有佐证、有数据、有引用的，或是有权威人士或大公司生产系统背书的资料。应该是被时间和实践检验过的，或是小心求证过的，不是拍脑袋野路子或是道听途说出来的资料。</p><p>3）应该是加入了一些自己的经验和思考，可以引发人深思的，是所谓信息的密集很大的文章。</p><h4 id="2-注重基础和原理"><a href="#2-注重基础和原理" class="headerlink" title="2.注重基础和原理"></a>2.注重基础和原理</h4><p>如果你学习过底层的 Socket 编程，了解多路复用和各种 I&#x2F;O 模型的话（select, poll, epoll, aio, windows completion port, libevent 等），那么，对于 Node.js、Java NIO、Nginx、C++ 的 ACE 框架等这些中间件或是编程框架，你就会发现，无论表现形式是什么样的，其底层原理都是一个样的。</p><p>无论是 JVM 还是 Node，或者是 Python 解释器里干了什么，它都无法逾越底层操作系统 API 对“物理世界”的限制。而当你了解了这个底层物理世界以后，无论那些技术玩成什么花样，它们都无法超出你的掌控</p><h4 id="3-使用知识图"><a href="#3-使用知识图" class="headerlink" title="3.使用知识图"></a>3.使用知识图</h4><p>画知识图的方式可以让你从一个技术最重要最主干的地方出发开始遍历所有的技术细节，也就是画地图的方式。如果你不想在知识的海洋中迷路，你需要有一份地图，所以，<strong>学习并不是为了要记忆那些知识点，而是为了要找到一个知识的地图，你在这个地图上能通过关键路径找到你想要的答案</strong>。</p><h3 id="三、深度、归纳和坚持实践"><a href="#三、深度、归纳和坚持实践" class="headerlink" title="三、深度、归纳和坚持实践"></a>三、深度、归纳和坚持实践</h3><h4 id="1-系统地学习"><a href="#1-系统地学习" class="headerlink" title="1.系统地学习"></a>1.系统地学习</h4><p><strong>学习模板</strong>：</p><p>​1）<strong>这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题</strong>。</p><p>​2）<strong>这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off （权衡）是什么</strong>。</p><p>​3）<strong>这个技术适用的场景</strong>。</p><p>​4）<strong>技术的组成部分和关键点</strong>。</p><p>​5）<strong>技术的底层原理和关键实现</strong>。</p><p>​6）<strong>已有的实现和它之间的对比</strong>。</p><h4 id="2-举一反三"><a href="#2-举一反三" class="headerlink" title="2.举一反三"></a>2.举一反三</h4><p><strong>三种基本能力</strong>：</p><p>​1）<strong>联想能力</strong>。这种能力的锻炼需要你平时就在不停地思考同一个事物的不同的用法，或是联想与之有关的别的事物。对于软件开发和技术学习也一样。</p><p>​2）<strong>抽象能力</strong>。抽象能力是举一反三的基本技能。平时你解决问题的时候，如果你能对这个问题进行抽象，你就可以获得更多的表现形式。抽象能力需要找到解决问题的通用模型，比如数学就是对现实世界的一种抽象。只要我们能把现实世界的各种问题建立成数据模型（如，建立各种维度的向量），我们就可以用数学来求解，这也是机器学习的本质。</p><p>​3）<strong>自省能力</strong>。所谓自省能力就是自己找自己的难看。当你得到一个解的时候，要站在自己的对立面来找这个解的漏洞。有点像左右手互博。这种自己和自己辩论的能力又叫思辨能力。将自己分裂成正反方，左右方，甚至多方，站在不同的立场上来和自己辩论，从而做到不漏过一个 case，从而获得完整全面的问题分析能力。</p><h4 id="3-总结和归纳"><a href="#3-总结和归纳" class="headerlink" title="3.总结和归纳"></a>3.总结和归纳</h4><p><strong>我们积累的知识越多，在知识间进行联系和区辨的能力就越强，对知识进行总结和归纳也就越轻松</strong>。</p><p><strong>学习的开始阶段，可以不急于总结归纳，不急于下判断，做结论，而应该保留部分知识的不确定性，保持对知识的开放状态</strong>。</p><p><strong>总结归纳方法</strong>：把你看到和学习到的信息，归整好，排列好，关联好，总之把信息碎片给结构化掉，然后在结构化的信息中，找到规律，找到相通之处，找到共同之处，进行简化、归纳和总结，最终形成一种套路，一种模式，一种通用方法。</p><h4 id="4-实践出真知"><a href="#4-实践出真知" class="headerlink" title="4.实践出真知"></a>4.实践出真知</h4><p><strong>实践是很累很痛苦的事，但只有痛苦才会让人反思，而反思则是学习和改变自己的动力。Grow up through the pain， 是非常有道理的</strong>。</p><h4 id="5-坚持不懈"><a href="#5-坚持不懈" class="headerlink" title="5.坚持不懈"></a>5.坚持不懈</h4><p><strong>一方面你要把你的坚持形成成果晒出来，让别人来给你点赞，另一方面，你还要把坚持变成一种习惯，就像吃饭喝水一样，你感觉不到太多的成本付出。只有做到这两点，你才能够真正坚持</strong>。</p><h3 id="四、如何学习和阅读代码"><a href="#四、如何学习和阅读代码" class="headerlink" title="四、如何学习和阅读代码"></a>四、如何学习和阅读代码</h3><h4 id="1-读文档还是读代码"><a href="#1-读文档还是读代码" class="headerlink" title="1.读文档还是读代码"></a>1.读文档还是读代码</h4><p><strong>如果你想了解一种思想，一种方法，一种原理，一种思路，一种经验，恐怕，读书和读文档会更有效率一些</strong></p><p><strong>如果你想了解的就是具体细节，比如某协程的实现，某个模块的性能，某个算法的实现，那么你还是要去读代码的</strong></p><h4 id="2-如何阅读源代码"><a href="#2-如何阅读源代码" class="headerlink" title="2.如何阅读源代码"></a>2.如何阅读源代码</h4><p><strong>阅读代码的前提</strong></p><p>​1）<strong>基础知识</strong>。相关的语言和基础技术的知识。</p><p>​2）<strong>软件功能</strong>。你先要知道这个软件完成的是什么样的功能，有哪些特性，哪些配置项。你先要读一遍用户手册，然后让软件跑起来，自己先用一下感受一下。</p><p>​3）<strong>相关文档</strong>。读一下相关的内部文档，Readme 也好，Release Notes 也好，Design 也好，Wiki 也好，这些文档可以让你明白整个软件的方方面面。如果你的软件没有文档，那么，你只能指望这个软件的原作者还在，而且他还乐于交流。</p><p>​4）<strong>代码的组织结构</strong>。也就是代码目录中每个目录是什么样的功能，每个文档是干什么的。如果你要读的程序是在某种标准的框架下组织的，比如：Java 的 Spring 框架，那么恭喜你，这些代码不难读了。</p><p><strong>软件代码的一般构成</strong></p><p>​1）<strong>接口抽象定义</strong></p><p>​2）<strong>模块粘合层</strong></p><p>​3）<strong>业务流程</strong></p><p>​4）<strong>具体实现</strong>（代码逻辑（业务逻辑和控制逻辑）、出错处理、数据处理、重要的算法、底层交互）</p><p><strong>阅读代码的方法</strong></p><p>​1）一般采用自顶向下，从总体到细节的“剥洋葱皮”的读法。</p><p>​2）画图是必要的，程序流程图，调用时序图，模块组织图……</p><p>​3）代码逻辑归一下类，排除杂音，主要逻辑才会更清楚。</p><p>​4）debug 跟踪一下代码是了解代码在执行中发生了什么的最好方式。</p><h3 id="五、如何面对枯燥和量大的知识"><a href="#五、如何面对枯燥和量大的知识" class="headerlink" title="五、如何面对枯燥和量大的知识"></a>五、如何面对枯燥和量大的知识</h3><h4 id="1-如何面对枯燥的知识"><a href="#1-如何面对枯燥的知识" class="headerlink" title="1.如何面对枯燥的知识"></a>1.如何面对枯燥的知识</h4><p><strong>解决方法</strong>：</p><p>​1）了解用处：这个知识对于你来说来太高级了，你可能不知道能用在什么地方。</p><p>​2）人的认知是从感性认识向理性认识转化的，所以，你可能要先去找一下应用场景，学点更实用的，再回来学理论。</p><p>​3）学习需要有反馈，有成就感，带着相关问题去学习会更好。</p><p>​4）当然，找到牛人来给你讲解，也是一个很不错的手段。</p><h4 id="2-如何面对大量的知识"><a href="#2-如何面对大量的知识" class="headerlink" title="2.如何面对大量的知识"></a>2.如何面对大量的知识</h4><p>一点一点学，一口一口吃。注重基础，画知识图，多问为什么，多动手，然后坚持住。</p><p>带着问题去学习，带着要解决的东西去学习，带着挑战去学习，于是每当你解决了一个问题，做了一个功能，完成了一个挑战，你就会感到兴奋和有成就感。这样，你也就找到了源源不断的学习驱动力。</p><p>把你学习的心得、过程、笔记、代码分享出来，找到和你一同学习的人，因为一个人长跑很辛苦，有人同行就会好很多，就算没有人同行，你的读者，你的观众也会为你鼓掌加油，这些也是让你持续前行的动力。</p><h4 id="3-认真阅读文档"><a href="#3-认真阅读文档" class="headerlink" title="3.认真阅读文档"></a>3.认真阅读文档</h4><p>很多技术问题都是出在技术人员不认真读技术手册上。用户手册（User Manual）一定要好好地读一读，很多很多提示都在里面了，这是让你可以少掉很多坑的法宝。</p><h4 id="4-其他几个实用的技巧"><a href="#4-其他几个实用的技巧" class="headerlink" title="4.其他几个实用的技巧"></a>4.其他几个实用的技巧</h4><p>​1）<strong>用不同的方式来学习同一个东西</strong>。比如：通过看书，听课，创建脑图，写博客，讲课，解决实际问题，等等。</p><p>​2）<strong>不要被打断</strong>。</p><p>​3）<strong>总结压缩信息</strong>。</p><p>​4）<strong>把未知关联到已知</strong>。</p><p>​5）<strong>用教的方式来学习</strong>。</p><p>​6）<strong>学以致用</strong>。</p><p>​7）<strong>不要记忆</strong>。</p><p>​8）<strong>多犯错误</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2D-2D特征点匹配法计算相机运动</title>
    <link href="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/"/>
    <url>/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="2D-2D特征点匹配法计算相机运动"><a href="#2D-2D特征点匹配法计算相机运动" class="headerlink" title="2D-2D特征点匹配法计算相机运动"></a>2D-2D特征点匹配法计算相机运动</h3><h4 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一.基础知识"></a>一.基础知识</h4><p>在介绍通过2D图像之间的特征点匹配计算相机运动之前，不得不介绍一下相关的基础知识，主要包括相机成像的原理，针孔相机模型以及齐次坐标系的介绍。</p><h5 id="1-相机成像原理"><a href="#1-相机成像原理" class="headerlink" title="1.相机成像原理"></a>1.相机成像原理</h5><p>首先，我们来看一下一张照片是如何拍出来的，下面是一个单反相机。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906125008273.png" alt="image-20220906125008273" style="zoom: 50%;"><p>我们将该相机的主要结构抽象出来，如下所示。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906125519206.png" alt="image-20220906125519206" style="zoom:50%;"><p>我们的拍照过程通常是这样：找到一个合适的角度，通过取景器⑧观察画面，当画面符合我们要求时，按下快门，就完成了拍照的过程。</p><p>以上这个简单的拍照过程，主要包含两个步骤，一是取景，二是按快门。我们在做这两个动作的时候发生了什么呢？</p><p>首先是取景，光线通过镜头①射到反光镜②上，然后反射到五棱镜⑦上，通过五棱镜的反射，光线到达取景器⑧,我们通过观察取景器就能看到我们要拍的画面。</p><p>然后是按快门，在按快门之前，反光镜位于②位置，用于反射光线以便我们取景，当我们按下快门的瞬间，反光镜从②拉到⑤，这样光线就直接射到传感器③上，照片就形成了。</p><h4 id="二-相机模型"><a href="#二-相机模型" class="headerlink" title="二.相机模型"></a>二.相机模型</h4><p>相机将三维世界的坐标点映射到二维图像平面的过程可以用一个几何模型来描述，我们称这个模型为相机模型。相机模型有很多种，最简单的是针孔相机模型。</p><p>针孔相机模型背后的原理就是小孔成像原理，我们来复习一下小孔成像原理，通过下面这个实验来唤醒大家的记忆。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906132354607.png" alt="image-20220906132354607" style="zoom:33%;"><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906132216158.png" alt="image-20220906132216158" style="zoom: 33%;"><p>上面这个实验我们可以观察到，F形状的光源发射的光线通过中间的带有小孔的挡板，在最右侧的成像板上形成一个倒立的F图像。</p><p>我们可以通过小孔成像模型来解释针孔相机模型。将模型抽象得到下图。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906140414382.png" alt="image-20220906140414382" style="zoom:50%;"><p>其中P是世界中真实的点，P&#96;是P在二维图像中的投影点。</p><p>针孔相机模型总共包括4个坐标系，分别是像素坐标系、图像坐标系、相机坐标系和世界坐标系</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tp">像素坐标系：以图像平面左上角为原点的坐标系，<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴分别平行于图像坐标系的<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴。用（u,v）表示其坐标值。<br>图像坐标系：以光心在图像平面投影为原点的坐标系，<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴分别平行于图像平面的两条垂直边，用（x`,y`）表示其坐标值。图像坐标系是用物理单位表示像素在图像中的位置。<br>相机坐标系：以相机光心为原点的坐标系，<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴分别平行于图像坐标系的<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴，相机的光轴为<span class="hljs-keyword">Z</span>轴，用(x,y,z)表示其坐标值。<br>世界坐标系：是三维世界的绝对坐标系，我们需要用它来描述三维环境中的任何物体的位置，用(xw,yw,zw)表示其坐标值。<br></code></pre></td></tr></table></figure><p><strong>我们研究这个针孔相机模型的目的就是为了确定P&#96;和P之间的几何关系</strong>。</p><p>设P在相机坐标系下的坐标为（X,Y,Z）,P&#96;在图像坐标系下的坐标为（X‘，Y‘，Z‘）,我们最后想得到的是像素坐标系下的P‘和相机坐标系下的P之间的关系。</p><p>首先，我们通过相机模型可以得到一个相似三角形</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906152439601.png" alt="image-20220906152439601" style="zoom:50%;"><p>其中f是焦距（光心到成像平面中心的距离），根据相似三角形的关系，我们可以得到</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906153318214.png" alt="image-20220906153318214" style="zoom:80%;"><p>其中负号表示成像是倒立的。为了方便，我们将成像平面根据光心做中心对称。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906153519037.png" alt="image-20220906153519037" style="zoom:50%;"><p>得到如下关系：</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906153624669.png" alt="image-20220906153624669" style="zoom: 80%;"><p>整理得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173327131.png" alt="image-20220906173327131" style="zoom:50%;"><p><strong>像素坐标系下的P‘和图像坐标系下的P‘的关系</strong></p><p>已知P‘点在图像坐标系上的坐标，求P‘点在像素坐标系上的坐标。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173226600.png" alt="image-20220906173226600" style="zoom:33%;"><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173352530.png" alt="image-20220906173352530" style="zoom:50%;"><p>其中，cx和cy表示图像坐标原点到像素坐标原点的位移（单位为像素），α和β分别表示图像坐标系中x轴和y轴每单位有多少个像素，单位为（像素&#x2F;米）。</p><p><strong>像素坐标系下的P‘和相机坐标系下的P之间的关系</strong></p><p>结合式（5,3）,把αf合并为fx，βf合并为fy，（5,4）式可转化为相机坐标系中的P点和其在像素坐标系上的投影点P&#96;之间的关系</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173530923.png" alt="image-20220906173530923" style="zoom: 50%;"><p>把（u,v）用转成齐次坐标并将上式写成矩阵形式</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173706053.png" alt="image-20220906173706053" style="zoom:50%;"><p>其中K&#x3D;<img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906174040157.png" alt="image-20220906174040157" style="zoom:33%;">称为<strong>相机的内参</strong></p><p>将5.6式中1&#x2F;Z的值并入（X,Y,Z)^T向量，相当于P点在相机坐标系下的坐标(X,Y,Z)除以Z，即（X&#x2F;Z,Y&#x2F;Z,1)，我们称这个坐标为P点在<strong>归一化平面</strong>上的坐标。从而我们得到了像素坐标系下的P&#96;和归一化平面上P的关系：即归一化平面上P的坐标左乘相机内参K就得到了像素坐标系下的P’。</p><h4 id="三-对极几何"><a href="#三-对极几何" class="headerlink" title="三.对极几何"></a>三.对极几何</h4><p>这部分，我们将介绍真实世界中的点与相机在不同视角下成像的对应点之间的几何约束关系。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906180251744.png" alt="image-20220906180251744" style="zoom:50%;"><p>上图P是真实世界的点，p1是相机光心位于O1时，P点投影到投影平面I1上的对应点，同理，p2是相机光心位于O2时，P点投影到投影平面I2上的对应点。</p><p>连接O1和O2，连线和两个投影面的交点e1,e2称为<strong>极点</strong>。</p><p>O1PO2三点构成的平面称为<strong>极平面</strong>。</p><p>极平面与投影平面的相交线称为<strong>极线</strong>。</p><p>当我们不知道p1在投影平面I2上的对应点p2时，我们就无法确定P的具体位置，但我们可以知道P一定在O1与p1连接线射线上，也可以确定极平面，通过极平面我们可以确定极线，虽然我们无法确定p2的具体位置，但我们可以知道p2一定在极线上。</p><h5 id="1-p1和p2之间的几何约束"><a href="#1-p1和p2之间的几何约束" class="headerlink" title="1.p1和p2之间的几何约束"></a>1.p1和p2之间的几何约束</h5><p>当相机光心位于O1时，即相机坐标系原点位于O1时，设P在相机坐标系下坐标为（X,Y,Z)。通过第二部分介绍的内容，我们可以知道p1和P之间的几何关系为</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220907163501707.png" alt="image-20220914164835353" style="zoom: 70%;"><p>记为式（5.7），其中s1就是Z。</p><p>当相机光心位于O2时，O1到O2的变换关系为O2&#x3D;RO1+t，其中R代表旋转，t代表平移。所以有</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220907163826376.png" alt="image-20220914164835353" style="zoom: 70%;"><p>记为式（5.8），其中，假设相机坐标系原点位于O2时，且P在相机坐标系下坐标为（X2,Y2,Z2)，则s2就等于Z2，现在为了使相机坐标系统一，将O2的相机坐标系映射到O1，已知两个相机坐标系的变换关系，O2是O1通过旋转变换R和平移变换t得到的，所以（X2,Y2,Z2）&#x3D;R(X,Y,Z)+t。</p><p>设P在相机坐标系O1的归一化平面上的坐标为x1，则由p1与x1关系为</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914164835353.png" alt="image-20220914164835353" style="zoom: 33%;"><p>同理设P在相机坐标系O2的归一化平面上的坐标为x2，则p2与x2关系为</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914164801359.png" alt="image-20220914164801359" style="zoom: 33%;"><p>代入式5.7和式5.8得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914165319117.png" alt="image-20220914165319117" style="zoom: 33%;"><p>整理得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914170150719.png" alt="image-20220914170150719" style="zoom: 33%;"><p>5.11两边同乘t^，即两边同时和t做外积得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914170312941.png" alt="image-20220914170312941" style="zoom: 33%;"><p>式5.12两边同乘x2^T,即两边同时和x2做内积得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914170726917.png" alt="image-20220914170726917" style="zoom: 33%;"><p>因为t和x2的外积t^x2同时垂直于t和x2，所以5.12式左侧与x2的内积为0，则有</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914171001932.png" alt="image-20220914171001932" style="zoom: 33%;"><p>重新代入p1和p2得式5.15</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914171245580.png" alt="image-20220914171245580" style="zoom:50%;"><p>我们把t^R记作基础矩阵F，把式5.15中间部分即为本质矩阵E，得到<strong>对极约束</strong></p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914171744533.png" alt="image-20220914171744533" style="zoom:50%;"><p>由此，我们可以得到相机位姿估计问题求解步骤</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1.</span>根据配对点的像素坐标求出<span class="hljs-built_in">E</span>或者<span class="hljs-variable">F</span>（八点法）<br><span class="hljs-number">2.</span>根据<span class="hljs-built_in">E</span>或<span class="hljs-variable">F</span>求出<span class="hljs-variable">R</span><span class="hljs-operator">,</span><span class="hljs-variable">t</span><br></code></pre></td></tr></table></figure><p>如果已知相机内参K，外参R和t，我们就可以求出本质矩阵E和基础矩阵F（在实际应用中，由于相机参数的测量误差以及图像中的噪声等因素，计算出的本质矩阵可能会存在误差。）。在图像配准深度学习方法中，使用带有相机内参K，外参R和t的数据集，我们就可以使用E或者F作为监督信号，步骤如下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1.</span>通过深度学习模型得到两幅图像的特征点对<br><span class="hljs-number">2.</span>通过特征点对的像素坐标求出<span class="hljs-built_in">E</span>或者<span class="hljs-variable">F</span><span class="hljs-punctuation">(</span>八点法<span class="hljs-punctuation">)</span><br><span class="hljs-number">3.</span>将得到和<span class="hljs-built_in">E</span>或者<span class="hljs-variable">F</span>与通过数据集自带参数<span class="hljs-built_in">K</span>，<span class="hljs-variable">R</span>，<span class="hljs-variable">t</span>计算得到的<span class="hljs-built_in">E</span>或者<span class="hljs-variable">F</span>计算损失。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>图像匹配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像配准</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
