<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>YFCC100M和SUN3D数据集提取代码分析</title>
    <link href="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="YFCC100M和SUN3D数据集提取代码分析"><a href="#YFCC100M和SUN3D数据集提取代码分析" class="headerlink" title="YFCC100M和SUN3D数据集提取代码分析"></a>YFCC100M和SUN3D数据集提取代码分析</h1><h3 id="一、数据集结构"><a href="#一、数据集结构" class="headerlink" title="一、数据集结构"></a>一、数据集结构</h3><p><strong>1.字段</strong></p><p>​<strong>1）’xs’：</strong>初始匹配对的归一化平面坐标:</p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/69910bfaa6af2645824ca4a1ff8f7a9c.svg"><p>​<strong>2）’ys’：</strong>通过相机外参计算得到基础矩阵，然后计算所有匹配对在基础矩阵作用下偏差。正确的匹配对有如下关系:</p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20231226153509842.png"><p>如果不是正确匹配对的话，在基础矩阵F作用下值不为0，实际的代码中最后的结果进行了平方操作和归一化操作，所以ys的值全部是大于等于0的。</p><p>​<strong>3）’Rs’：</strong>两个图像对的相对旋转矩阵</p><p>​<strong>4） ‘ts’：</strong>两个图像对的相对平移向量</p><p>​<strong>5）’ratios’：</strong>计算描述子相似度时，每个特征点与其他特征点的描述符之间最小的欧式距离和第二小的欧式距离之比</p><p>​<strong>6） ‘mutuals’：</strong>是否互为最匹配点</p><p>​<strong>7） ‘cx1s’：</strong>表示图像1坐标原点到像素坐标原点在x轴方向的位移（单位为像素），图像坐标原点默认在图像中心，而像素坐标原点在左上角</p><p>​<strong>8）’cy1s’：</strong>表示图像1坐标原点到像素坐标原点在y轴方向的位移（单位为像素），图像坐标原点默认在图像中心，而像素坐标原点在左上角</p><p>​<strong>9）’f1s’：</strong>表示图像1的两个相机内参$f_x$和$f_y$，其中 $f_x$&#x3D; $\alpha f$,其中$\alpha$是图像坐标系x轴每单位代表的像素数，$f$表示焦距，$f_y$同理。</p><p>​<strong>10）’cx2s’：</strong>表示图像2坐标原点到像素坐标原点在x轴方向的位移（单位为像素），图像坐标原点默认在图像中心，而像素坐标原点在左上角</p><p>​<strong>11）’cy2s’：</strong>表示图像2坐标原点到像素坐标原点在y轴方向的位移（单位为像素），图像坐标原点默认在图像中心，而像素坐标原点在左上角</p><p>​<strong>12）’f2s’：</strong>表示图像2的两个相机内参$f_x$和$f_y$，其中 $f_x$&#x3D; $\alpha f$,其中$\alpha$是图像坐标系x轴每单位代表的像素数，$f$表示焦距，$f_y$同理。</p><p>​</p><h3 id="二、代码执行总体流程"><a href="#二、代码执行总体流程" class="headerlink" title="二、代码执行总体流程"></a>二、代码执行总体流程</h3><p><strong>1.提取特征点和对应的描述子</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python extract_feature.py<br></code></pre></td></tr></table></figure><p>会为每张图片生成一个hdf5文件（类似字典格式），文件里面存储的是该图片的所有特征点[‘kepoints’]及其描述子[‘descriptors’]</p><p><strong>2.生成dataset</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python yfcc.py<br></code></pre></td></tr></table></figure><p><strong>调用过程</strong></p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20231226234000625.png" alt="image-20231226234000625" style="zoom:50%;"><p><strong>2.1.构建图片对</strong></p><p>在sequence.py文件中的Sequence类初始化过程中构建(dataset.py—&gt;self.dump_data()–&gt;dataset&#x3D;Sequence())。在每个场景的图片中根据visibility.txt中的能见度阈值挑选出能见度大于指定阈值（50）的图片进行两两配对。在每个场景中随机选取指定数量的图片对。</p><p><strong>2.2.特征点匹配</strong></p><p>dataset.py—&gt;self.dump_data()–&gt;dataset&#x3D;Sequence()–&gt;dataset.dump_intermediate()</p><p>构建完图片对后，对每个图片对的特征点采用最近邻算法进行特征点匹配。得到<strong>idx_sort、ratio_test、mutual_nearest</strong>，存储到h5文件中。</p><p><strong>idx_sort</strong>:包含两个数组，第一个数组为图片1中特征点编号，第二个数组为与图片1特征点最近的图片2的特征点编号</p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/1665576292447-3fe423ae-fa84-4abc-b7b2-38a0b78e39e4.png"><p><strong>mutual_nearest</strong>:表示是否是互最近邻的数组，0代表不是互最近邻，1代表是互最近邻</p><p><strong>ratio_test</strong>:最近邻与次近邻欧式距离比</p><p><strong>2.3.保存数据</strong></p><p>dataset.py—&gt;self.dump_data()–&gt;dataset&#x3D;Sequence()–&gt;dataset.dump_datasets()</p><p>通过self.make_xy()接口来获取需要的字段信息。</p><p>所有字段信息分开保存为pkl文件，比如xs字段，每个场景保存一个xs.pkl文件</p><p><strong>2.4.所有场景的数据存入一个h5py文件中</strong></p><p>dataset.py—&gt;self.dump_data()–&gt;self.collect()</p><p><strong>h5py文件结构</strong></p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20231226232629013.png"><p>每个group代表一个字段，group里面的每个dataset表示每对图片对的字段信息</p><h3 id="三、代码结构"><a href="#三、代码结构" class="headerlink" title="三、代码结构"></a>三、代码结构</h3><p><strong>1.代码文件</strong></p><img src="/2023/12/26/YFCC100M%E5%92%8CSUN3D%E6%95%B0%E6%8D%AE%E9%9B%86%E6%8F%90%E5%8F%96%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/image-20231226145926201.png"><p><strong>extract_feature.py</strong>：通过SIFT算法提取特征点和对应的描述子，生成hdf5文件存储每张图片的所有特征点和对应的描述子</p><p><strong>yfcc.py</strong>：生成yfcc100m的训练集、测试集和验证集</p><p><strong>dataset.py</strong>：被yfcc.py调用，用于生成dataset</p><p><strong>geom.py</strong>：处理相机内外参的接口，被sequence.py调用</p><p><strong>transformations.py</strong>：被geom.py调用，用于处理四元数</p><p><strong>sequence.py</strong>：提取图像对，计算图像对的相对的相机外参</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>图像匹配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像配准</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左耳听风文章阅读笔记-高效学习篇</title>
    <link href="/2023/12/25/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E7%AF%87/"/>
    <url>/2023/12/25/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="左耳听风文章阅读笔记-高效学习篇"><a href="#左耳听风文章阅读笔记-高效学习篇" class="headerlink" title="左耳听风文章阅读笔记-高效学习篇"></a>左耳听风文章阅读笔记-高效学习篇</h1><h3 id="一、端正学习态度"><a href="#一、端正学习态度" class="headerlink" title="一、端正学习态度"></a>一、端正学习态度</h3><p>学习是一件“逆人性”的事，就像锻炼身体一样，<strong>需要人持续付出，会让人感到痛苦，并随时想找理由放弃</strong>。</p><h4 id="1-主动学习和被动学习"><a href="#1-主动学习和被动学习" class="headerlink" title="1.主动学习和被动学习"></a>1.主动学习和被动学习</h4><p><strong>学习金字塔</strong></p><img src="/2023/12/25/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E7%AF%87/image-20231225141950468.png" alt="image-20231225141950468" style="zoom:50%;"><p><strong>被动学习</strong>：听讲、阅读、视听、演示</p><p><strong>主动学习</strong>：讨论、实践、教授他人</p><p><strong>学习不是努力读更多的书，盲目追求阅读的速度和数量，这会让人产生低层次的勤奋和成长的感觉，这只是在使蛮力。要思辨，要践行，要总结和归纳，否则，你只是在机械地重复某件事，而不会有质的成长的。</strong></p><h4 id="2-浅度学习和深度学习"><a href="#2-浅度学习和深度学习" class="headerlink" title="2.浅度学习和深度学习"></a>2.浅度学习和深度学习</h4><p><strong>深度学习的关键</strong>：</p><p>​1）高质量的信息源和第一手的知识</p><p>​2）把知识连成地图，将自己的理解反述出来</p><p>​3）不断地反思和思辨，与不同年龄段的人讨论</p><p>​4）举一反三，并践行之，把知识转换成技能</p><p><strong>学习的三个步骤</strong>：</p><p>​1）知识采集</p><p>​2）知识缝合（将信息组织起来，形成结构体。连接记忆，逻辑推理，知识梳理）</p><p>​3）技能转换（举一反三，实践和练习以及传授教导）</p><h4 id="3-学习的目的"><a href="#3-学习的目的" class="headerlink" title="3.学习的目的"></a>3.学习的目的</h4><p>**学习是为了找到方法 ** 学习是为了找到通往答案的路径和方法，是为了拥有无师自通的能力。</p><p><strong>学习是为了找到原理</strong> 一旦理解和掌握了这些本质的东西，你就会发现，整个复杂多变的世界在变得越来越简单。你就好像找到了所有问题的最终答案似的，一通百通了。</p><p><strong>学习是为了了解自己</strong> 开拓眼界的目的就是发现自己的不足和上升空间，从而才能让自己成长。</p><p><strong>学习是为了改变自己</strong> 学习是为了改变自己的思考方式，改变自己的思维方式，改变自己与生俱来的那些垃圾和低效的算法。总之，学习让我们改变自己，行动和践行，反思和改善，从而获得成长。</p><h3 id="二、源头、原理和知识地图"><a href="#二、源头、原理和知识地图" class="headerlink" title="二、源头、原理和知识地图"></a>二、源头、原理和知识地图</h3><h4 id="1-挑选知识和信息源"><a href="#1-挑选知识和信息源" class="headerlink" title="1.挑选知识和信息源"></a>1.挑选知识和信息源</h4><p><strong>好信息源的特质</strong></p><p>1）应该是第一手资料，不是被别人理解过、消化过的二手资料。尤其对于知识性的东西来说，更是这样。应该是原汁原味的，不应该是被添油加醋的。</p><p>2）应该是有佐证、有数据、有引用的，或是有权威人士或大公司生产系统背书的资料。应该是被时间和实践检验过的，或是小心求证过的，不是拍脑袋野路子或是道听途说出来的资料。</p><p>3）应该是加入了一些自己的经验和思考，可以引发人深思的，是所谓信息的密集很大的文章。</p><h4 id="2-注重基础和原理"><a href="#2-注重基础和原理" class="headerlink" title="2.注重基础和原理"></a>2.注重基础和原理</h4><p>如果你学习过底层的 Socket 编程，了解多路复用和各种 I&#x2F;O 模型的话（select, poll, epoll, aio, windows completion port, libevent 等），那么，对于 Node.js、Java NIO、Nginx、C++ 的 ACE 框架等这些中间件或是编程框架，你就会发现，无论表现形式是什么样的，其底层原理都是一个样的。</p><p>无论是 JVM 还是 Node，或者是 Python 解释器里干了什么，它都无法逾越底层操作系统 API 对“物理世界”的限制。而当你了解了这个底层物理世界以后，无论那些技术玩成什么花样，它们都无法超出你的掌控</p><h4 id="3-使用知识图"><a href="#3-使用知识图" class="headerlink" title="3.使用知识图"></a>3.使用知识图</h4><p>画知识图的方式可以让你从一个技术最重要最主干的地方出发开始遍历所有的技术细节，也就是画地图的方式。如果你不想在知识的海洋中迷路，你需要有一份地图，所以，<strong>学习并不是为了要记忆那些知识点，而是为了要找到一个知识的地图，你在这个地图上能通过关键路径找到你想要的答案</strong>。</p><h3 id="三、深度、归纳和坚持实践"><a href="#三、深度、归纳和坚持实践" class="headerlink" title="三、深度、归纳和坚持实践"></a>三、深度、归纳和坚持实践</h3><h4 id="1-系统地学习"><a href="#1-系统地学习" class="headerlink" title="1.系统地学习"></a>1.系统地学习</h4><p><strong>学习模板</strong>：</p><p>​1）<strong>这个技术出现的背景、初衷和要达到什么样的目标或是要解决什么样的问题</strong>。</p><p>​2）<strong>这个技术的优势和劣势分别是什么，或者说，这个技术的 trade-off （权衡）是什么</strong>。</p><p>​3）<strong>这个技术适用的场景</strong>。</p><p>​4）<strong>技术的组成部分和关键点</strong>。</p><p>​5）<strong>技术的底层原理和关键实现</strong>。</p><p>​6）<strong>已有的实现和它之间的对比</strong>。</p><h4 id="2-举一反三"><a href="#2-举一反三" class="headerlink" title="2.举一反三"></a>2.举一反三</h4><p><strong>三种基本能力</strong>：</p><p>​1）<strong>联想能力</strong>。这种能力的锻炼需要你平时就在不停地思考同一个事物的不同的用法，或是联想与之有关的别的事物。对于软件开发和技术学习也一样。</p><p>​2）<strong>抽象能力</strong>。抽象能力是举一反三的基本技能。平时你解决问题的时候，如果你能对这个问题进行抽象，你就可以获得更多的表现形式。抽象能力需要找到解决问题的通用模型，比如数学就是对现实世界的一种抽象。只要我们能把现实世界的各种问题建立成数据模型（如，建立各种维度的向量），我们就可以用数学来求解，这也是机器学习的本质。</p><p>​3）<strong>自省能力</strong>。所谓自省能力就是自己找自己的难看。当你得到一个解的时候，要站在自己的对立面来找这个解的漏洞。有点像左右手互博。这种自己和自己辩论的能力又叫思辨能力。将自己分裂成正反方，左右方，甚至多方，站在不同的立场上来和自己辩论，从而做到不漏过一个 case，从而获得完整全面的问题分析能力。</p><h4 id="3-总结和归纳"><a href="#3-总结和归纳" class="headerlink" title="3.总结和归纳"></a>3.总结和归纳</h4><p><strong>我们积累的知识越多，在知识间进行联系和区辨的能力就越强，对知识进行总结和归纳也就越轻松</strong>。</p><p><strong>学习的开始阶段，可以不急于总结归纳，不急于下判断，做结论，而应该保留部分知识的不确定性，保持对知识的开放状态</strong>。</p><p><strong>总结归纳方法</strong>：把你看到和学习到的信息，归整好，排列好，关联好，总之把信息碎片给结构化掉，然后在结构化的信息中，找到规律，找到相通之处，找到共同之处，进行简化、归纳和总结，最终形成一种套路，一种模式，一种通用方法。</p><h4 id="4-实践出真知"><a href="#4-实践出真知" class="headerlink" title="4.实践出真知"></a>4.实践出真知</h4><p><strong>实践是很累很痛苦的事，但只有痛苦才会让人反思，而反思则是学习和改变自己的动力。Grow up through the pain， 是非常有道理的</strong>。</p><h4 id="5-坚持不懈"><a href="#5-坚持不懈" class="headerlink" title="5.坚持不懈"></a>5.坚持不懈</h4><p><strong>一方面你要把你的坚持形成成果晒出来，让别人来给你点赞，另一方面，你还要把坚持变成一种习惯，就像吃饭喝水一样，你感觉不到太多的成本付出。只有做到这两点，你才能够真正坚持</strong>。</p><h3 id="四、如何学习和阅读代码"><a href="#四、如何学习和阅读代码" class="headerlink" title="四、如何学习和阅读代码"></a>四、如何学习和阅读代码</h3><h4 id="1-读文档还是读代码"><a href="#1-读文档还是读代码" class="headerlink" title="1.读文档还是读代码"></a>1.读文档还是读代码</h4><p><strong>如果你想了解一种思想，一种方法，一种原理，一种思路，一种经验，恐怕，读书和读文档会更有效率一些</strong></p><p><strong>如果你想了解的就是具体细节，比如某协程的实现，某个模块的性能，某个算法的实现，那么你还是要去读代码的</strong></p><h4 id="2-如何阅读源代码"><a href="#2-如何阅读源代码" class="headerlink" title="2.如何阅读源代码"></a>2.如何阅读源代码</h4><p><strong>阅读代码的前提</strong></p><p>​1）<strong>基础知识</strong>。相关的语言和基础技术的知识。</p><p>​2）<strong>软件功能</strong>。你先要知道这个软件完成的是什么样的功能，有哪些特性，哪些配置项。你先要读一遍用户手册，然后让软件跑起来，自己先用一下感受一下。</p><p>​3）<strong>相关文档</strong>。读一下相关的内部文档，Readme 也好，Release Notes 也好，Design 也好，Wiki 也好，这些文档可以让你明白整个软件的方方面面。如果你的软件没有文档，那么，你只能指望这个软件的原作者还在，而且他还乐于交流。</p><p>​4）<strong>代码的组织结构</strong>。也就是代码目录中每个目录是什么样的功能，每个文档是干什么的。如果你要读的程序是在某种标准的框架下组织的，比如：Java 的 Spring 框架，那么恭喜你，这些代码不难读了。</p><p><strong>软件代码的一般构成</strong></p><p>​1）<strong>接口抽象定义</strong></p><p>​2）<strong>模块粘合层</strong></p><p>​3）<strong>业务流程</strong></p><p>​4）<strong>具体实现</strong>（代码逻辑（业务逻辑和控制逻辑）、出错处理、数据处理、重要的算法、底层交互）</p><p><strong>阅读代码的方法</strong></p><p>​1）一般采用自顶向下，从总体到细节的“剥洋葱皮”的读法。</p><p>​2）画图是必要的，程序流程图，调用时序图，模块组织图……</p><p>​3）代码逻辑归一下类，排除杂音，主要逻辑才会更清楚。</p><p>​4）debug 跟踪一下代码是了解代码在执行中发生了什么的最好方式。</p><h3 id="五、如何面对枯燥和量大的知识"><a href="#五、如何面对枯燥和量大的知识" class="headerlink" title="五、如何面对枯燥和量大的知识"></a>五、如何面对枯燥和量大的知识</h3><h4 id="1-如何面对枯燥的知识"><a href="#1-如何面对枯燥的知识" class="headerlink" title="1.如何面对枯燥的知识"></a>1.如何面对枯燥的知识</h4><p><strong>解决方法</strong>：</p><p>​1）了解用处：这个知识对于你来说来太高级了，你可能不知道能用在什么地方。</p><p>​2）人的认知是从感性认识向理性认识转化的，所以，你可能要先去找一下应用场景，学点更实用的，再回来学理论。</p><p>​3）学习需要有反馈，有成就感，带着相关问题去学习会更好。</p><p>​4）当然，找到牛人来给你讲解，也是一个很不错的手段。</p><h4 id="2-如何面对大量的知识"><a href="#2-如何面对大量的知识" class="headerlink" title="2.如何面对大量的知识"></a>2.如何面对大量的知识</h4><p>一点一点学，一口一口吃。注重基础，画知识图，多问为什么，多动手，然后坚持住。</p><p>带着问题去学习，带着要解决的东西去学习，带着挑战去学习，于是每当你解决了一个问题，做了一个功能，完成了一个挑战，你就会感到兴奋和有成就感。这样，你也就找到了源源不断的学习驱动力。</p><p>把你学习的心得、过程、笔记、代码分享出来，找到和你一同学习的人，因为一个人长跑很辛苦，有人同行就会好很多，就算没有人同行，你的读者，你的观众也会为你鼓掌加油，这些也是让你持续前行的动力。</p><h4 id="3-认真阅读文档"><a href="#3-认真阅读文档" class="headerlink" title="3.认真阅读文档"></a>3.认真阅读文档</h4><p>很多技术问题都是出在技术人员不认真读技术手册上。用户手册（User Manual）一定要好好地读一读，很多很多提示都在里面了，这是让你可以少掉很多坑的法宝。</p><h4 id="4-其他几个实用的技巧"><a href="#4-其他几个实用的技巧" class="headerlink" title="4.其他几个实用的技巧"></a>4.其他几个实用的技巧</h4><p>​1）<strong>用不同的方式来学习同一个东西</strong>。比如：通过看书，听课，创建脑图，写博客，讲课，解决实际问题，等等。</p><p>​2）<strong>不要被打断</strong>。</p><p>​3）<strong>总结压缩信息</strong>。</p><p>​4）<strong>把未知关联到已知</strong>。</p><p>​5）<strong>用教的方式来学习</strong>。</p><p>​6）<strong>学以致用</strong>。</p><p>​7）<strong>不要记忆</strong>。</p><p>​8）<strong>多犯错误</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2D-2D特征点匹配法计算相机运动</title>
    <link href="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/"/>
    <url>/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="2D-2D特征点匹配法计算相机运动"><a href="#2D-2D特征点匹配法计算相机运动" class="headerlink" title="2D-2D特征点匹配法计算相机运动"></a>2D-2D特征点匹配法计算相机运动</h3><h4 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一.基础知识"></a>一.基础知识</h4><p>在介绍通过2D图像之间的特征点匹配计算相机运动之前，不得不介绍一下相关的基础知识，主要包括相机成像的原理，针孔相机模型以及齐次坐标系的介绍。</p><h5 id="1-相机成像原理"><a href="#1-相机成像原理" class="headerlink" title="1.相机成像原理"></a>1.相机成像原理</h5><p>首先，我们来看一下一张照片是如何拍出来的，下面是一个单反相机。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906125008273.png" alt="image-20220906125008273" style="zoom: 50%;"><p>我们将该相机的主要结构抽象出来，如下所示。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906125519206.png" alt="image-20220906125519206" style="zoom:50%;"><p>我们的拍照过程通常是这样：找到一个合适的角度，通过取景器⑧观察画面，当画面符合我们要求时，按下快门，就完成了拍照的过程。</p><p>以上这个简单的拍照过程，主要包含两个步骤，一是取景，二是按快门。我们在做这两个动作的时候发生了什么呢？</p><p>首先是取景，光线通过镜头①射到反光镜②上，然后反射到五棱镜⑦上，通过五棱镜的反射，光线到达取景器⑧,我们通过观察取景器就能看到我们要拍的画面。</p><p>然后是按快门，在按快门之前，反光镜位于②位置，用于反射光线以便我们取景，当我们按下快门的瞬间，反光镜从②拉到⑤，这样光线就直接射到传感器③上，照片就形成了。</p><h4 id="二-相机模型"><a href="#二-相机模型" class="headerlink" title="二.相机模型"></a>二.相机模型</h4><p>相机将三维世界的坐标点映射到二维图像平面的过程可以用一个几何模型来描述，我们称这个模型为相机模型。相机模型有很多种，最简单的是针孔相机模型。</p><p>针孔相机模型背后的原理就是小孔成像原理，我们来复习一下小孔成像原理，通过下面这个实验来唤醒大家的记忆。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906132354607.png" alt="image-20220906132354607" style="zoom:33%;"><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906132216158.png" alt="image-20220906132216158" style="zoom: 33%;"><p>上面这个实验我们可以观察到，F形状的光源发射的光线通过中间的带有小孔的挡板，在最右侧的成像板上形成一个倒立的F图像。</p><p>我们可以通过小孔成像模型来解释针孔相机模型。将模型抽象得到下图。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906140414382.png" alt="image-20220906140414382" style="zoom:50%;"><p>其中P是世界中真实的点，P&#96;是P在二维图像中的投影点。</p><p>针孔相机模型总共包括4个坐标系，分别是像素坐标系、图像坐标系、相机坐标系和世界坐标系</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tp">像素坐标系：以图像平面左上角为原点的坐标系，<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴分别平行于图像坐标系的<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴。用（u,v）表示其坐标值。<br>图像坐标系：以光心在图像平面投影为原点的坐标系，<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴分别平行于图像平面的两条垂直边，用（x`,y`）表示其坐标值。图像坐标系是用物理单位表示像素在图像中的位置。<br>相机坐标系：以相机光心为原点的坐标系，<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴分别平行于图像坐标系的<span class="hljs-keyword">X</span>轴和<span class="hljs-keyword">Y</span>轴，相机的光轴为<span class="hljs-keyword">Z</span>轴，用(x,y,z)表示其坐标值。<br>世界坐标系：是三维世界的绝对坐标系，我们需要用它来描述三维环境中的任何物体的位置，用(xw,yw,zw)表示其坐标值。<br></code></pre></td></tr></table></figure><p><strong>我们研究这个针孔相机模型的目的就是为了确定P&#96;和P之间的几何关系</strong>。</p><p>设P在相机坐标系下的坐标为（X,Y,Z）,P&#96;在图像坐标系下的坐标为（X‘，Y‘，Z‘）,我们最后想得到的是像素坐标系下的P‘和相机坐标系下的P之间的关系。</p><p>首先，我们通过相机模型可以得到一个相似三角形</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906152439601.png" alt="image-20220906152439601" style="zoom:50%;"><p>其中f是焦距（光心到成像平面中心的距离），根据相似三角形的关系，我们可以得到</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906153318214.png" alt="image-20220906153318214" style="zoom:80%;"><p>其中负号表示成像是倒立的。为了方便，我们将成像平面根据光心做中心对称。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906153519037.png" alt="image-20220906153519037" style="zoom:50%;"><p>得到如下关系：</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906153624669.png" alt="image-20220906153624669" style="zoom: 80%;"><p>整理得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173327131.png" alt="image-20220906173327131" style="zoom:50%;"><p><strong>像素坐标系下的P‘和图像坐标系下的P‘的关系</strong></p><p>已知P‘点在图像坐标系上的坐标，求P‘点在像素坐标系上的坐标。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173226600.png" alt="image-20220906173226600" style="zoom:33%;"><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173352530.png" alt="image-20220906173352530" style="zoom:50%;"><p>其中，cx和cy表示图像坐标原点到像素坐标原点的位移（单位为像素），α和β分别表示图像坐标系中x轴和y轴每单位有多少个像素，单位为（像素&#x2F;米）。</p><p><strong>像素坐标系下的P‘和相机坐标系下的P之间的关系</strong></p><p>结合式（5,3）,把αf合并为fx，βf合并为fy，（5,4）式可转化为相机坐标系中的P点和其在像素坐标系上的投影点P&#96;之间的关系</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173530923.png" alt="image-20220906173530923" style="zoom: 50%;"><p>把（u,v）用转成齐次坐标并将上式写成矩阵形式</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906173706053.png" alt="image-20220906173706053" style="zoom:50%;"><p>其中K&#x3D;<img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906174040157.png" alt="image-20220906174040157" style="zoom:33%;">称为<strong>相机的内参</strong></p><p>将5.6式中1&#x2F;Z的值并入（X,Y,Z)^T向量，相当于P点在相机坐标系下的坐标(X,Y,Z)除以Z，即（X&#x2F;Z,Y&#x2F;Z,1)，我们称这个坐标为P点在<strong>归一化平面</strong>上的坐标。从而我们得到了像素坐标系下的P&#96;和归一化平面上P的关系：即归一化平面上P的坐标左乘相机内参K就得到了像素坐标系下的P’。</p><h4 id="三-对极几何"><a href="#三-对极几何" class="headerlink" title="三.对极几何"></a>三.对极几何</h4><p>这部分，我们将介绍真实世界中的点与相机在不同视角下成像的对应点之间的几何约束关系。</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220906180251744.png" alt="image-20220906180251744" style="zoom:50%;"><p>上图P是真实世界的点，p1是相机光心位于O1时，P点投影到投影平面I1上的对应点，同理，p2是相机光心位于O2时，P点投影到投影平面I2上的对应点。</p><p>连接O1和O2，连线和两个投影面的交点e1,e2称为<strong>极点</strong>。</p><p>O1PO2三点构成的平面称为<strong>极平面</strong>。</p><p>极平面与投影平面的相交线称为<strong>极线</strong>。</p><p>当我们不知道p1在投影平面I2上的对应点p2时，我们就无法确定P的具体位置，但我们可以知道P一定在O1与p1连接线射线上，也可以确定极平面，通过极平面我们可以确定极线，虽然我们无法确定p2的具体位置，但我们可以知道p2一定在极线上。</p><h5 id="1-p1和p2之间的几何约束"><a href="#1-p1和p2之间的几何约束" class="headerlink" title="1.p1和p2之间的几何约束"></a>1.p1和p2之间的几何约束</h5><p>当相机光心位于O1时，即相机坐标系原点位于O1时，设P在相机坐标系下坐标为（X,Y,Z)。通过第二部分介绍的内容，我们可以知道p1和P之间的几何关系为</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220907163501707.png" alt="image-20220914164835353" style="zoom: 70%;"><p>记为式（5.7），其中s1就是Z。</p><p>当相机光心位于O2时，O1到O2的变换关系为O2&#x3D;RO1+t，其中R代表旋转，t代表平移。所以有</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220907163826376.png" alt="image-20220914164835353" style="zoom: 70%;"><p>记为式（5.8），其中，假设相机坐标系原点位于O2时，且P在相机坐标系下坐标为（X2,Y2,Z2)，则s2就等于Z2，现在为了使相机坐标系统一，将O2的相机坐标系映射到O1，已知两个相机坐标系的变换关系，O2是O1通过旋转变换R和平移变换t得到的，所以（X2,Y2,Z2）&#x3D;R(X,Y,Z)+t。</p><p>设P在相机坐标系O1的归一化平面上的坐标为x1，则由p1与x1关系为</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914164835353.png" alt="image-20220914164835353" style="zoom: 33%;"><p>同理设P在相机坐标系O2的归一化平面上的坐标为x2，则p2与x2关系为</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914164801359.png" alt="image-20220914164801359" style="zoom: 33%;"><p>代入式5.7和式5.8得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914165319117.png" alt="image-20220914165319117" style="zoom: 33%;"><p>整理得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914170150719.png" alt="image-20220914170150719" style="zoom: 33%;"><p>5.11两边同乘t^，即两边同时和t做外积得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914170312941.png" alt="image-20220914170312941" style="zoom: 33%;"><p>式5.12两边同乘x2^T,即两边同时和x2做内积得</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914170726917.png" alt="image-20220914170726917" style="zoom: 33%;"><p>因为t和x2的外积t^x2同时垂直于t和x2，所以5.12式左侧与x2的内积为0，则有</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914171001932.png" alt="image-20220914171001932" style="zoom: 33%;"><p>重新代入p1和p2得式5.15</p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914171245580.png" alt="image-20220914171245580" style="zoom:50%;"><p>我们把t^R记作基础矩阵F，把式5.15中间部分即为本质矩阵E，得到<strong>对极约束</strong></p><img src="/2022/09/06/2D-2D%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E6%B3%95%E8%AE%A1%E7%AE%97%E7%9B%B8%E6%9C%BA%E8%BF%90%E5%8A%A8/image-20220914171744533.png" alt="image-20220914171744533" style="zoom:50%;"><p>由此，我们可以得到相机位姿估计问题求解步骤</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1.</span>根据配对点的像素坐标求出<span class="hljs-built_in">E</span>或者<span class="hljs-variable">F</span>（八点法）<br><span class="hljs-number">2.</span>根据<span class="hljs-built_in">E</span>或<span class="hljs-variable">F</span>求出<span class="hljs-variable">R</span><span class="hljs-operator">,</span><span class="hljs-variable">t</span><br></code></pre></td></tr></table></figure><p>如果已知相机内参K，外参R和t，我们就可以求出本质矩阵E和基础矩阵F（在实际应用中，由于相机参数的测量误差以及图像中的噪声等因素，计算出的本质矩阵可能会存在误差。）。在图像配准深度学习方法中，使用带有相机内参K，外参R和t的数据集，我们就可以使用E或者F作为监督信号，步骤如下</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1.</span>通过深度学习模型得到两幅图像的特征点对<br><span class="hljs-number">2.</span>通过特征点对的像素坐标求出<span class="hljs-built_in">E</span>或者<span class="hljs-variable">F</span><span class="hljs-punctuation">(</span>八点法<span class="hljs-punctuation">)</span><br><span class="hljs-number">3.</span>将得到和<span class="hljs-built_in">E</span>或者<span class="hljs-variable">F</span>与通过数据集自带参数<span class="hljs-built_in">K</span>，<span class="hljs-variable">R</span>，<span class="hljs-variable">t</span>计算得到的<span class="hljs-built_in">E</span>或者<span class="hljs-variable">F</span>计算损失。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
      <category>图像匹配</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像配准</tag>
      
      <tag>科研</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
